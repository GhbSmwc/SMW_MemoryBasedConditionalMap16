<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: rgb(221, 221, 221);
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			div.CodeBlock {
				overflow: auto;
				width: 1000px;
				height: 500px;
				border: 1px solid white;
				resize: both;
				background-color: #101010;
			}
			pre {
				margin: 0px;
			}
			*.FixedWidth {
				font-family: monospace;
			}
			
			*.NoLineBreak {
				font-family: monospace;
				white-space: pre;
			}
			*.Center {
				text-align: center;
			}
			li {
				padding: 5px;
			}
			input {
				font-family: monospace;
			}
		</style>
	</head>
<body style="max-width: 1000px; margin: auto; padding: 15px">
<div>
	<div><a href="../Readme.html#MemoryCalculator2">Back (contents)</a></div>
	<div><a href="../Readme.html#JS_MemoryCalculator2_SRAMBwram">Back (SRAM/BWRAM tutorial)</a></div>
</div><br>
<div>
	Notes:
	<ul>
		<li>Hold down CTRL and double click code areas to instantly-select the entire text, then you can easily copy via CTRL+C.</li>
		<li>Make sure your browser supports <kbd>BigInt</kbd>.</li>
	</ul>
</div>
<table>
	<tr>
		<td><kbd>!Freeram_MBCM16_MemoryFlag</kbd> address:</td>
		<td>$<input type="text" value="7FAD49" id="Input_Freeram_MemoryFlagRAM" onkeydown="IncrementDecrementHex();" onchange="CorrectHexInput(); Calculate(); CalculateFlagNumber()" data-min="0x0" data-max="0xFFFFFF" data-padlength="6"></td>
	</tr>
	<tr>
		<td>Number of group-128s</td>
		<td><input type="number" value="2" id="Input_NumberOfGroup128s" min="1" max="16" onchange="CorrectDecimalInput(); CalculateFlagNumber(); Calculate(); CalculateFlagNumber()"></td>
	</tr>
	<tr>
		<td><kbd>!Freeram_MBCM16_KeyCounter</kbd> address:</td>
		<td>$<input type="text" value="7FAD79" id="Input_Freeram_KeyCounter" onkeydown="IncrementDecrementHex()" onchange="CorrectHexInput(); Calculate()" data-min="0x0" data-max="0xFFFFFF" data-padlength="6"></td>
	</tr>
	<tr>
		<td>Number of separate key counters</td>
		<td><input type="number" value="2" id="Input_NumberOfKeyCounters" min="1" max="256" onchange="CorrectDecimalInput(); Calculate();"></td>
	</tr>
</table>
<hr>
<table>
	<tr>
		<td><kbd>!Freeram_MBCM16_MemoryFlag</kbd> used:</td>
		<td><kbd id="Output_Freeram_MemoryFlagRAM_Usage"></kbd></td>
	</tr>
	<tr>
		<td>Flag numbering range:</td>
		<td><kbd id="Output_FlagNumberingRangeOfMemoryFlag"></kbd></td>
	</tr>
	<tr>
		<td><kbd>!Freeram_MBCM16_KeyCounter</kbd> used:</td>
		<td><kbd id="Output_NumberOfKeyCounters"></kbd></td>
	</tr>
</table><br>
<div>
	Flag display setting:
	<div><label><input type="radio" name="FlagNumberSetting" onchange="ToggleBitView();" id="FlagNumberSetting_Converter" checked>Converter view</label></div>
	<div><label><input type="radio" name="FlagNumberSetting" onchange="ToggleBitView(); Calculate()" id="FlagNumberSetting_Table">Table view</label></div>
	<div>
		<div class="CodeBlock" id="Output_FlagTable"></div>
		<div id="Output_Converter">
			<table>
				<tr>
					<td>Flag number:</td>
					<td><input type="number" value ="0" min="0" max="2047" onchange="CorrectDecimalInput(); CalculateFlagNumber();" id="FlagSearch_FlagNumber">($<input type="text" value="0" onkeydown="IncrementDecrementHex();" onchange="CorrectHexInput(); CalculateFlagNumber();" data-min="0x0" data-max="0x7FF" data-padlength="3">)</td>
				</tr>
				<tr>
					<td>Info:</td>
					<td><div class="CodeBlock" style="width: 400px; height: 100px;"><pre id="Output_Converter_Info" ></pre></div></td>
				</tr>
			</table>
		</div>
	</div>
</div>
<h3>Placeholder table templates</h3>
<div>I made this so it is easier to paste the tables in their respective ASM files. All you have to do is edit some placeholder values. Careful not to insert or delete items off the table that isn't the last (bottomost)
item, else you would have to move the comments (starting from the area that you've insert or deleted to the last) if you are using them to find what flags/level ID they are.</div><br>
<div>
	<h2>SRAM/BWRAM plus patch</h2>
	<div>
		Default flags:
		<div>
			<div><label><input type="radio" name="DefaultSRAMValue" id="SRAMDefault_00" onchange="Calculate()" checked><kbd>db %00000000</kbd></label></div>
			<div><label><input type="radio" name="DefaultSRAMValue" id="SRAMDefault_FF" onchange="Calculate()" ><kbd>db %11111111</kbd></label></div>
		</div>
	</div>
	<div class="CodeBlock"><pre id="SRAMBWRAMOutput"></pre></div>
</div>
<div>
	<h2>MBCM16SearchBlockFlagIndex.asm (custom blocks routine)</h2>
	<div class="CodeBlock"><pre id="MBCM16SearchBlockFlagIndexOutput"></pre></div>
</div>
<div>
	<h2>MBCM16WriteGroup128To7FC060.asm (uberasm tool)</h2>
	<div class="CodeBlock"><pre id="Level2Group128"></pre></div>
</div>
<script>
	Calculate()
	CalculateFlagNumber()
	function IncrementDecrementHex() {
		let ElementUsed = event.target
		let KeyPressed = event.key
		let MinValue = BigInt(ElementUsed.dataset.min)
		let MaxValue = BigInt(ElementUsed.dataset.max)
		let Value = 0n
		try {
			Value = BigInt("0x" + ElementUsed.value)
		} catch {}
		if (!/(?:ArrowUp|ArrowDown)/.test(KeyPressed)) {
			return
		}
		event.preventDefault()
		if (KeyPressed == "ArrowUp") {
			Value++
		} else {
			Value--
		}
		Value = BigintClamp(Value, MinValue, MaxValue)
		ElementUsed.value = Value.toString(16).padStart(parseInt(ElementUsed.dataset.padlength), "0").toUpperCase()
		ElementUsed.onchange()
	}
	function CorrectDecimalInput() {
		let ElementUsed = event.target
		let Value = 0n
		let MinValue = BigInt(ElementUsed.min)
		let MaxValue = BigInt(ElementUsed.max)
		try {
			Value = BigintClamp(BigInt(ElementUsed.value), MinValue, MaxValue)
		} catch {}
		ElementUsed.value = Value.toString(10)
		let CorrespondingHexInput = ElementUsed.parentNode.querySelector("input[type=text]")
		if (CorrespondingHexInput != null) {
			CorrespondingHexInput.value = Value.toString(16).padStart(parseInt(CorrespondingHexInput.dataset.padlength), "0").toUpperCase()
		}
	}
	function CorrectHexInput() {
		let ElementUsed = event.target
		let Value = 0n
		let MinValue = BigInt(ElementUsed.dataset.min)
		let MaxValue = BigInt(ElementUsed.dataset.max)
		try {
			Value = BigInt("0x" + ElementUsed.value)
		} catch {}
		Value = BigintClamp(Value, MinValue, MaxValue)
		ElementUsed.value = Value.toString(16).padStart(parseInt(ElementUsed.dataset.padlength), "0").toUpperCase()
		
		let CorrespondingDecimalInput = ElementUsed.parentNode.querySelector("input[type=number]")
		if (CorrespondingDecimalInput != null) {
			CorrespondingDecimalInput.value = Value.toString(10)
		}
	}
	function BigintClamp(num, min, max) {
		//Restrict a number within a specified range, bigInt edition.
		return num <= min ? min : num >= max ? max : num;
	}
	function Calculate() {
		let Value_Freeram_MemoryFlagRAM = BigInt("0x" + document.getElementById("Input_Freeram_MemoryFlagRAM").value)
		let Value_NumberOfGroup128s = BigInt(document.getElementById("Input_NumberOfGroup128s").value)
		let Value_Freeram_KeyCounter = BigInt("0x" + document.getElementById("Input_Freeram_KeyCounter").value)
		let Value_NumberOfKeyCounters = BigInt(document.getElementById("Input_NumberOfKeyCounters").value)
		
		let NumberOfBytesOfMemoryFlagRAM = Value_NumberOfGroup128s*16n
		let NumberOfBitsOfMemoryFlagRAM = NumberOfBytesOfMemoryFlagRAM*8n
		
		let FlagTable = document.getElementById("Output_FlagTable")
		while (FlagTable.lastElementChild) { //Clear the table
			FlagTable.removeChild(FlagTable.lastElementChild)
		}
		
		document.getElementById("Output_Freeram_MemoryFlagRAM_Usage").textContent = "$" + Value_Freeram_MemoryFlagRAM.toString(16).padStart(6, "0").toUpperCase() + "~$" + (Value_Freeram_MemoryFlagRAM+NumberOfBytesOfMemoryFlagRAM-1n).toString(16).padStart(6, "0").toUpperCase() + " (" + NumberOfBytesOfMemoryFlagRAM.toString(10) + " bytes)"
		document.getElementById("Output_FlagNumberingRangeOfMemoryFlag").textContent = "0~" + (NumberOfBitsOfMemoryFlagRAM-1n).toString(10) + " ($0000~$" + (NumberOfBitsOfMemoryFlagRAM-1n).toString(16).padStart(4, "0").toUpperCase() + ", " + NumberOfBitsOfMemoryFlagRAM.toString(10) + " bits)"
		
		{
			let Text = "$" + Value_Freeram_KeyCounter.toString(16).padStart(6, "0").toUpperCase() + "~$" + (Value_Freeram_KeyCounter+Value_NumberOfKeyCounters-1n).toString(16).padStart(6, "0").toUpperCase() + " (" + Value_NumberOfKeyCounters.toString(10) + " bytes)"
			if (Value_NumberOfKeyCounters == 1n) {
				Text = "$" + Value_Freeram_KeyCounter.toString(16).padStart(6, "0").toUpperCase() + " (1 byte)"
			}
			document.getElementById("Output_NumberOfKeyCounters").textContent = Text
		}
		
		//Generate flag table
		let TableAndConverterSetting = document.getElementById("FlagNumberSetting_Table").checked
		document.getElementById("Output_FlagTable").hidden = !TableAndConverterSetting
		document.getElementById("Output_Converter").hidden = TableAndConverterSetting
		
		if (TableAndConverterSetting) {
			let Table = document.createElement("table")
			let Table_HeaderRow = document.createElement("tr")
			Table.appendChild(Table_HeaderRow)
			
			let Td_EmptyCellForGroupColumn = document.createElement("td")
			Td_EmptyCellForGroupColumn.setAttribute("rowspan", "2")
			Table_HeaderRow.appendChild(Td_EmptyCellForGroupColumn)
			
			let Table_Header_RAMAddresses = document.createElement("th")
			Table_Header_RAMAddresses.appendChild(document.createTextNode("RAM address"))
			Table_Header_RAMAddresses.setAttribute("colspan", "2")
			Table_HeaderRow.appendChild(Table_Header_RAMAddresses)
			
			let Table_Header_BitWithinByte = document.createElement("th")
			Table_Header_BitWithinByte.appendChild(document.createTextNode("Bit within each byte"))
			Table_Header_BitWithinByte.setAttribute("colspan", "8")
			Table_HeaderRow.appendChild(Table_Header_BitWithinByte)
			
			let Table_HeaderRow2_Subtype = document.createElement("tr")
			
			let Table_Header2_MemoryFlagRAMLabel = document.createElement("th")
			Table_Header2_MemoryFlagRAMLabel.appendChild(document.createTextNode("!Freeram_MBCM16_MemoryFlag address"))
			Table_Header2_MemoryFlagRAMLabel.style.fontFamily = "monospace"
			Table_HeaderRow2_Subtype.appendChild(Table_Header2_MemoryFlagRAMLabel)
			
			let Table_Header2_LMCM16AddrLabel = document.createElement("th")
			Table_Header2_LMCM16AddrLabel.appendChild(document.createTextNode("LM's $7FC060"))
			Table_Header2_LMCM16AddrLabel.style.fontFamily = "monospace"
			Table_HeaderRow2_Subtype.appendChild(Table_Header2_LMCM16AddrLabel)
			
			for (let i = 0n; i < 8n; i++) {
				let Th_Bit = document.createElement("th")
				Th_Bit.appendChild(document.createTextNode("Bit " + (7n-i).toString(10)))
				Th_Bit.style.fontFamily = "monospace"
				Table_HeaderRow2_Subtype.appendChild(Th_Bit)
			}
			
			Table.appendChild(Table_HeaderRow2_Subtype)
			
			
			let LMCM16Address = BigInt("0x7FC060")
			for (let i=0n; i < NumberOfBytesOfMemoryFlagRAM; i++) {
				let TableRow = document.createElement("tr")
				if (i % 16n == 0n) {
					let GroupNumber = i/16n
					let FlagStartingNumber = i*8n
					let FlagEndingNumber = FlagStartingNumber + 127n
					let Group128SeperatorTh = document.createElement("th")
					Group128SeperatorTh.style.whiteSpace = "pre"
					Group128SeperatorTh.setAttribute("rowspan", "16")
					Group128SeperatorTh.appendChild(document.createTextNode("Group $" + GroupNumber.toString(16).toUpperCase() + "\nFlags $" + FlagStartingNumber.toString(16).padStart(3, "0").toUpperCase() + "~$" + FlagEndingNumber.toString(16).padStart(3, "0").toUpperCase()))
					
					TableRow.appendChild(Group128SeperatorTh)
				}
				let TableData_MemoryFlagRam = document.createElement("td")
				TableData_MemoryFlagRam.style.fontFamily = "monospace"
				TableData_MemoryFlagRam.appendChild(document.createTextNode("$" + (Value_Freeram_MemoryFlagRAM+i).toString(16).padStart(6, "0").toUpperCase() + " (Addr+" + i.toString(10) +"/$" + i.toString(16).toUpperCase() + ")"))
				TableRow.appendChild(TableData_MemoryFlagRam)
				
				let TableData_LMCM16Ram = document.createElement("td")
				TableData_LMCM16Ram.style.fontFamily = "monospace";
				
				let LMCM16Address_Wrapped16 = LMCM16Address+(i % 16n);
				TableData_LMCM16Ram.appendChild(document.createTextNode("$" + LMCM16Address_Wrapped16.toString(16).toUpperCase()))
				TableRow.appendChild(TableData_LMCM16Ram)
				
				for (let i2 = 0n; i2 < 8n; i2++) {
					let Td_Bit = document.createElement("td")
					Td_Bit.style.fontFamily = "monospace"
					Td_Bit.style.whiteSpace = "pre"
					
					let StartingBitOffset = i*8n
					let BitInByte = 7n-i2
					let BitSinceStart = StartingBitOffset+BitInByte
					
					let LMCM16BitCount = BitSinceStart % 128n
					Td_Bit.appendChild(document.createTextNode("Flag: $" + BitSinceStart.toString(16).padStart(3, "0").toUpperCase() + "\n  LM:  $" + LMCM16BitCount.toString(16).padStart(2, "0").toUpperCase()))
					
					
					TableRow.appendChild(Td_Bit)
				}
				
				
				
				Table.appendChild(TableRow)
			}
			FlagTable.appendChild(Table)
		}
		//Generate SRAM/BWRAM output
		{
			let Text = ""
			
			Text += "\tdl $" + Value_Freeram_KeyCounter.toString(16).padStart(6, "0").toUpperCase() + " : dw " + Value_NumberOfKeyCounters.toString(10) + "\t\t;>!Freeram_MBCM16_KeyCounter\n"
			Text += "\tdl $" + Value_Freeram_MemoryFlagRAM.toString(16).padStart(6, "0").toUpperCase() + " : dw " + NumberOfBytesOfMemoryFlagRAM.toString(10) + "\t\t;>!Freeram_MBCM16_MemoryFlag\n"
			Text += "\t;[...]\n"
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Default values for how many keys you picked up.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n`
			for (let i =0n; i < Value_NumberOfKeyCounters; i++) {
				Text += "\tdb $00\t\t;>$" + (Value_Freeram_KeyCounter+i).toString(16).padStart(6, "0").toUpperCase() + "\n"
			}
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Default spawn flags for the MBCM16 blocks when you start up your new file
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n`
			let DefaultValue = "%00000000"
			if (document.getElementById("SRAMDefault_FF").checked) {
				DefaultValue = "%11111111"
			}
			for (let i = 0n; i < NumberOfBytesOfMemoryFlagRAM; i++) {
				let StartingBitOffset = i*8n
				let LastBitWithinByte = StartingBitOffset+7n
				let GroupNumber = i/16n
				Text += "\tdb " + DefaultValue + "\t\t;>$" + (Value_Freeram_MemoryFlagRAM+i).toString(16).padStart(6, "0").toUpperCase() + " (Byte " + i.toString(10) + "/$" + i.toString(16).toUpperCase() + "), flags $" + StartingBitOffset.toString(16).padStart(3, "0").toUpperCase() + "~$" + LastBitWithinByte.toString(16).padStart(3, "0").toUpperCase() + ", group $" + GroupNumber.toString(16).toUpperCase()
				if (i != NumberOfBytesOfMemoryFlagRAM-1n) {
					Text += "\n"
				}
			}
			document.getElementById("SRAMBWRAMOutput").textContent = Text
		}
		//Generate MBCM16SearchBlockFlagIndex.asm tables //MBCM16SearchBlockFlagIndexOutput
		{
			let Text = ""
			let LevelNumbersTableText = ""
			let LayerNumberTableText = ""
			let LevelCoordinateTableText = ""
			for (let i=0n; i<NumberOfBitsOfMemoryFlagRAM; i++) {
				let LMFlagNumber = i % 128n
				let GroupNumber = i / 128n
				let IndexingComment = ";>Flag $" + i.toString(16).toUpperCase() + " (Group $" + GroupNumber.toString(16).toUpperCase() + ") -> LM\'s CM16 flag $" + LMFlagNumber.toString(16).toUpperCase() + "\n"
				
				LevelNumbersTableText += "\tdw $FFFF\t\t" + IndexingComment
				LayerNumberTableText += "\tdb $00\t\t" + IndexingComment
				LevelCoordinateTableText  += "\tdw GetC800IndexHorizLvl($01B0, $0000, $0000)\t\t" + IndexingComment
				
			}
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;List of level numbers the flag is used in. This is essentially what level
;the flags are in.
;
;Note: you CAN have duplicate level numbers here if you have multiple flags
;in a single level.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
?GetFlagNumberLevelIndexStart:\n`
			Text += LevelNumbersTableText
			Text += "?GetFlagNumberLevelIndexEnd:\n"
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;List of what layer the flag is on. Put "$01" for layer 2 blocks if you
;are using a layer 2 level and have that flagged block on that layer, otherwise put "$00" instead.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
?GetFlagNumberLayerProcessingStart:\n`
			Text += LayerNumberTableText
			Text += `?GetFlagNumberLayerProcessingEnd:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;List of positions.
;With the help of asar's function (not sure if Xkas first made this or not),
;adding a location to the table is very easy. Format:
;
;dw GetC800IndexHorizLvl($HHHH, $XXXX, $YYYY)
;dw GetC800IndexVertiLvl($XXXX, $YYYY)
;
;-$HHHH is the level height (in pixels), basically RAM address $13D7. Fastest way to
; know what value is this in a level is in lunar magic, hover your mouse on the last
; row of blocks, and the status bar on the window (<XPos_in_hex>,<YPos_in_hex>:<TileNumber>),
; take the <YPos_in_hex> and add 1 AND THEN multiply by $10 (or just add a zero at the end;
; example: ($1A + 1)*$10 = $1B0)
;-$XXXX and $YYYY are the block coordinates, in units of 16x16 blocks (not pixels).
;
;Technically, these are C800 block indexes, not XY positions. Reason why it stores data as indexes
;is so that it consumes less space with each entry occupies 2 bytes of memory, instead of 4.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
?GetFlagNumberC800IndexStart:\n`
			Text += LevelCoordinateTableText
			Text += "?GetFlagNumberC800IndexEnd:"
			document.getElementById("MBCM16SearchBlockFlagIndexOutput").textContent = Text
		}
		//Generate MBCM16WriteGroup128To7FC060.asm tables
		{
			let Text = ""
			
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;List of levels. Each nth item in both tables represents a level associated to what group 128. You cannot
;have one level with multiple group-128s, however you can have multiple levels using the same group-128,
;which that saves you memory if you find one level using less than 128 flags.
;
;Also, you cannot have duplicate level numbers here, else during
;running this, it will ONLY take the last level number of the duplicates
;matching with the current level number.
;
;Although I could simply only have the table [.OneHundredTwentyEightFlagGroupList], have the index be
;the level number (X ranging from $0000 to $01FF), and have the value $FF to indcate that the level does
;not use MBCM16, it is very possible that you may have levels that don't use MBCM16 at all, thus resulting
;lots of unused values in the table with $FF, which waste space.
;
; Example:
;  .LevelList
;   dw $0105    ;>1st
;   dw $0106    ;>2nd
;   dw $0103    ;>3rd
;  .OneHundredTwentyEightFlagGroupList ;(here, values are GroupNumber*$10)
;   db $00   ;>1st
;   db $00   ;>2nd
;   db $10   ;>3rd
; ;Which means levels $0105 and $0106 would use group $0, to use flags $000 to $07F. Level $0103 would
; ;use group $1, using flags $080 to $0FF.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LevelList\n`
			let LevelListText = ""
			let WhatGroup128Text = ""
			for (let i = 0n; i < 64n; i++) {
				let BottomID = i*8n
				let TopID = BottomID+7n
				let IndexingComment = ";>Correlation ID: " + BottomID.toString(10) + "~" + TopID.toString(10)
				
				LevelListText += "\tdw $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF, $FFFF\t" + IndexingComment + "\n"
				WhatGroup128Text += "\tdb $00, $00, $00, $00, $00, $00, $00, $00\t" + IndexingComment + "\n"
			}
			Text += LevelListText
			Text += "..End\n"
			Text += `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;This table specifies what group-128 each level should use.
;Only enter numbers here as [$X0], where X is the group number in hex (therefore, numbers here must be
;multiples of 16: [ValueYouPutHere = GroupNumber * $10]).
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.OneHundredTwentyEightFlagGroupList\n`
			Text += WhatGroup128Text
			Text += "..End"
			
			document.getElementById("Level2Group128").textContent = Text
		}
	}
	
	function CalculateFlagNumber() {
		let OutputText = ""
		let Freeram = BigInt("0x" + document.getElementById("Input_Freeram_MemoryFlagRAM").value)
		let EnteredFlagNumber = BigInt(document.getElementById("FlagSearch_FlagNumber").value)
		let LMCM16BitNumberToUse = EnteredFlagNumber % 128n
		let Group128Number = EnteredFlagNumber/128n
		let Freeram_Offsetter = EnteredFlagNumber/8n
		let BitNumberWithinByte = EnteredFlagNumber % 8n
		let LM_7FC060_Offsetter = Freeram_Offsetter % 16n
		let MaxBitNumber = (BigInt(document.getElementById("Input_NumberOfGroup128s").value)*128n)-1n
		
		let WhatBitToDisplayString = (1n<<BitNumberWithinByte).toString(2).padStart(8, "0").replaceAll("0", "x")
		
		if (EnteredFlagNumber > MaxBitNumber) {
			OutputText += "Error! Flag number beyond the last available bit.\nHighest bit number is " + MaxBitNumber.toString(10) + "/$" + MaxBitNumber.toString(16).toUpperCase() + "."
		} else {
			OutputText += "RAM address byte written:      $" + (Freeram + Freeram_Offsetter).toString(16).padStart(6, "0").toUpperCase() + " (Addr+" + Freeram_Offsetter.toString(10) + "/$" + Freeram_Offsetter.toString(16).toUpperCase() + ")\n"
			OutputText += "Corresponding LM's CM16 RAM:   $" + (BigInt("0x7FC060")+LM_7FC060_Offsetter).toString(16).padStart(6, "0").toUpperCase() + " ($7FC060+" + LM_7FC060_Offsetter.toString(10) + "/$" + LM_7FC060_Offsetter.toString(16).toUpperCase() + ")\n"
			OutputText += "Bit within byte:               " + BitNumberWithinByte.toString(10) + " (%" + WhatBitToDisplayString + ")\n\n"
			
			OutputText += "Group to use:                  $" + Group128Number.toString(16).toUpperCase() + "\n"
			OutputText += "LM CM16 number to enter:       $" + LMCM16BitNumberToUse.toString(16).padStart(2, "0").toUpperCase()
		}
		
		document.getElementById("Output_Converter_Info").textContent = OutputText
	}
	function ToggleBitView() {
		let Boolean_FlagSetting = document.getElementById("FlagNumberSetting_Converter").checked
		document.getElementById("Output_Converter").hidden = !Boolean_FlagSetting
		document.getElementById("Output_FlagTable").hidden = Boolean_FlagSetting
	}
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}
</script>